---
layout: post
title: "Securing Flutter Apps with Auth0"
description: "Learn how to secure Flutter apps with Auth0 while using the Authorization Code Grant Flow with PKCE"
date: "2019-02-18 08:30"
author:
  name: "Fabusuyi Ayodeji"
  url: "roscoefab"
  mail: "dejifab@outlook.com"
  avatar: "https://twitter.com/roscoefab/profile_image?size=original"
related:
- 2017-11-15-an-example-of-all-possible-elements
---

**TL;DR:** [Flutter](https://flutter.io/) is Google's cross-plaform SDK created to help developers build expressive and beautiful mobile applications. In this article, you will learn how to build and secure a Flutter application with Auth0 using the Authorization Code Grant Flow with PKCE. You can checkout the code developed throughout the article [in this GitHub repository](https://github.com/thedejifab/flutter_auth0).

## Prerequisites

Before getting started with this article, you need a working knowledge of Flutter. If you need help getting started, you can follow the codelabs on the [Flutter website](https://flutter.io/docs/codelabs). 

You also need to have the installations outlined below on your machine.

* [Flutter SDK](https://flutter.io/docs/get-started/install), version 1.0 or later. (This comes with a [Dart SDK](https://www.dartlang.org/install) installation)
* A Development Environment, one of:
  * [Android Studio](https://developer.android.com/studio), version 3.0 or later, or
  * [IntelliJ IDEA](https://www.jetbrains.com/idea/download/), version 2017.1 or later, or
  * Visual Studio Code. 
  with Dart and Flutter plugins installed.

> **Note:** Additionally, if you have a knack for well-architected code, you'll find this very enjoyable.

## OAuth 2.0 Flow and Mobile Applications

OAuth 2.0 is an industry-standard protocol for authorization. It allows the delegation of user **authorization** (not authentication) responsibilities to other services. A typical example of OAuth 2.0 in action can be seen when trying to sign up for a third-party app using Facebook. OAuth 2.0 helps the third-party app delegate user authorization tasks to Facebook without having to bear the weight of securing user credentials. 

OAuth 2.0 provides [different flows](https://auth0.com/docs/api-auth/which-oauth-flow-to-use) for user authorization, with the [Authorization Code Grant Flow with PKCE](https://auth0.com/docs/api-auth/tutorials/authorization-code-grant-pkce) being the recommended approach for securing mobile applications. A detailed illustration of how this is used in the application developed in the article is shown below.

![Create application screenshot](images/flow.png)

## Project Setup

In this section, you will setup the application to be used throughout the article. More specifically, you will:

* Create an Auth0 application to represent your Flutter app,
* Scaffold a new Flutter app,
* Install packages that the app is dependent on.

### Creating an Auth0 project

Auth0 is an Identity-as-a-Service (IDaaS) platform that provides enterprises with features such as [**Social Login**](https://auth0.com/learn/social-login/) and [**Passwordless Login**](https://auth0.com/passwordless) amongst many others, aimed at easing the process of online identity management.

To integrate Auth0 into your Flutter app, you need an Auth0 account. If you have an exisiting account, you can use it. If you don't, [click here to create one](https://auth0.com/signup).

Upon creating an Auth0 account, follow the steps below to setup an application.
* Go to the [Applications](https://manage.auth0.com/#/applications) section of your dashboard
* Click on the [Create Application](https://manage.auth0.com/#/applications/create) button.
* Enter a name for your application (e.g "Flutter Application")
* Finally, select "Native App" as the application type and click the Create button.

![Create application screenshot](images/auth0.png)

After creating an application, navigate to the **Settings** tab of your application to set a callback URI in the **Allowed Callback URLs** field. 

<!-- add notes about enabling Signin with Github -->

This could be any value ranging from normal web URLs with an HTTP scheme (E.g `https://myapp.com`) to URIs with custom schemes (E.g `myapp://logincallback`). In my case, I used the latter and made it unique. If you don't know the purpose of the callback URI, don't worry, the article will explain this concept into details later.

### Scaffolding a Flutter project

To facilitate the process of creating a new Flutter project you are going to use the Flutter CLI tool. To do this, open a terminal and navigate to your projects directory to run the following command. 

```bash
flutter create flutter_app
```

The CLI tool generates a template project within a couple of seconds to get you started. The tool requires internet connection to download dependencies during project creation, except an `--offline-project` option is passed to the `create` command to defer the downloading of dependencies. After project generation, you can now open the project in your preferred IDE.

### Installing dependencies

As you will see in the course of the article, the project requires three major dependencies - the [`rebloc`](https://pub.dartlang.org/packages/rebloc) package to use ReBLOC for state management, the [`http`](https://pub.dartlang.org/packages/http) package for performing network requests, the [`crypto`](https://pub.dartlang.org/packages/crypto) package for generating secure codes used in the authorization process, and the [`uni_links`](https://pub.dartlang.org/packages/uni_links) package which affords the ability to deep-link from web URLs into a Flutter application.

With the project open in your IDE, navigate to your `/pubspec.yaml` file to add the dependencies by modifying the `dependencies` section as seen below. 

```dart
dependencies:
  flutter:
    sdk: flutter
  crypto: ^2.0.6
  rebloc: ^0.2.1
  uni_links: ^0.1.4
  http: ^0.12.0+1
```

Then, run `flutter packages get` command in your project's root directory with a stable internet connection to download the dependencies.

> **Note:** This article utilizes the [ReBLOC pattern](https://pub.dartlang.org/packages/rebloc). In the course of the article, you'll use concepts like actions, blocs, states, dispatchers and subscribers - all of which form the basis of the ReBLOC pattern. If you are not familiar with these concepts, don't worry, you will still be able to follow along with this article.

## Flutter and Auth0 in Practice

In this section, you will learn how to authorize users, fetch user details and log users out with Auth0 using the Authorization Code Grant Flow with PKCE. More specifically, you will learn how to:

* Setup an authorization URL;
  * Create a code verifier,
  * Create a code challenge,
  * Construct the authorization URL.
* Get the user's authorization;
  * Launch the authorization URL within your app,
  * Retrieve the authorization code.
* Access APIs after authorization;
  * Exchange authorization code for access tokens,
  * Fetch user profile with access token,
  * Persist refresh tokens for subsequent access.
* Handle logouts.
  * Handle application-layer logouts,
  * Handle Auth0-layer logouts.

<!--Add comments and a tree for folder structure  -->

### Setup an authorization URL

User authorization with Auth0 involves redirecting the user to an authorization URL which provides an authorization dialog. After authorization, the user is redirected to a callback URL which contains details about the user' authorization. An authorization URL requires parameters including `redirect_uri`, `client_id` and a few other parameters as seen [here](https://auth0.com/docs/protocols/oauth2#authorization-endpoint). Specifically, when authorizing using the Authorization Code Grant Flow with PKCE, the `code_challenge` and `code_challenge_method` parameters are required.

To get started with this, create a file named `url_utils.dart` in the `/lib/utils` directory and add the code below: 

```dart
import 'dart:math';
import 'dart:convert';

import 'package:crypto/crypto.dart';

const String DOMAIN = "<AUTH0_DOMAIN>";
const String CLIENT_ID = "<CLIENT_ID>";
const String AUDIENCE = "https://$DOMAIN/api/v2/";
const String SCOPES = "openid profile email offline_access";
const String REDIRECT_URI = "myapp://logincallback";

String codeVerifier;
String codeChallenge;
```

The code snippet above declares parameters necessary for the creation of an Authorization URL. The `REDIRECT_URI` variable specifies where the user will be redirected to after authorization. The value of `REDIRECT_URI` must match with one of the **Allowed Callback URLs** defined in the **Settings** tab of your Auth0 application.

On the other hand, the `SCOPES` variable specifies the kind of access required by your application. The `offline_access` option ensures that a `refresh_token` is retrieved alongside the `access_token` while exchanging the authorization code for access token. As you will see in latter parts of this article, the `refresh_token` eliminates the need for unneccessary repetition of the authorization process.

> **Note:** For the <AUTH0_DOMAIN> and <CLIENT_ID> placeholders, replace them with the **Domain** and **Client ID** fields that can be found in the **Settings** tab of your application.

#### Create a code verifier

A code verifier is a cryptographically random key used to generate a code challenge. To create a code verifier, append the snippet below to the `lib/utils/url_utils.dart` file:

```dart
///To create code verifier
String _createVerifier() {
  var generator = Random.secure();
  var verifier = List.generate(32, (x) => generator.nextInt(256));
  return base64UrlEncode(verifier).replaceAll("=", "");
}
```

<!-- Check what's here really -->
In the code above, a random list is generated and encoded as a Base64 String to get a code verifier.

> **Note:** The `.replaceAll("=","")` operation performed on the Base64 String removes the unrequired padding which leads to error when verifying the code challenge.

#### Create a code challenge

A code verifier is required when creating a code challenge to be passed to the authorization endpoint. As you'll see in [Exchange authorization code for access tokens]() section, the code verifier passed must be the same with the code verifier used in generating a code challenge. To create a code challenge, append the snippet below to the `lib/utils/url_utils.dart` file:

```dart
///To create code challenge
String _createChallenge(String verifier) {
  var enc = utf8.encode(verifier);
  var challenge = sha256.convert(enc).bytes;
  return base64UrlEncode(challenge).replaceAll("=", "");
}
```

The code snippet above encodes the code verifier using UTF8 and converts the result to a SHA256 byte before encoding again, this time into a Base64 String to generate the code challenge.

> **Note:** The SHA256 conversion method used in generating the digest byte determines what algorithm is used in verifying the code challenge in [Exchange authorization code for access tokens]() section.

#### Construct the authorization URL.

To wrap things up on setting up the authorization, add the code snippet below to the `lib/utils/url_utils.dart` file:

```dart
///To create authorization URL
String getAuthorizationUrl() {
  codeVerifier = _createVerifier();
  codeChallenge = _createChallenge(codeVerifier);
  String authorizationUrl =
      "https://$DOMAIN/authorize?scope=$SCOPES&audience=$AUDIENCE&response_type=code&client_id=$CLIENT_ID&code_challenge=$codeChallenge&code_challenge_method=S256&redirect_uri=$REDIRECT_URI";
  return authorizationUrl;
}
```

The `getAuthorizationUrl()` function initializes the `codeVerifier` and `codeChallenge` variables. It then uses them alongside previously initialized variables such as `DOMAIN` and `SCOPES` to build the `authorizationUrl`.

### Get the user's authorization
